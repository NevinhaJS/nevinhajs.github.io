{"title":"NevinhaJs","githubRepo":"nevinhajs/nevinhajs.github.io","index":{"title":"Home","description":"A component framework for making web animations development easier.","content":" Featured Examples ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/./","children":{"docs":{"title":"Documentation","description":"Everything you need to know to get started.","content":" NevinhaJs Docs Center Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/docs/search.html"},"basics":{"children":{"creating-your-fisrt-component":{"title":"Your first component","description":"We've seen how to setup our project, now we'll see how to create our first component using NevinhaJs.","layout":"guide","icon":"arrow-right-rod","weight":1,"content":" {$page.description} Importing NevinhaJs NevinhaJS works following the architecture of components (lifecycles, states ands props), motions and providers. By default we exports NevinhaComponent, render, NevinhaDOM and ParallaxProvider. For starting to use, the basics exported variables that you'll need to import, are: import {NevinhaComponent, render, NevinhaDOM} from 'nevinha-js'; Where: NevinhaComponent: The component class that is responsible to render your component instance. Every NevinhaComponent instance has it own lifecycle and state methods. render: The render method responsable for rendering your component, basically it takes your component markup and send for the Nevinha Js virtual DOM algorithm NevinhaDOM The method that converts JSX syntaxe to javascript object literal language. Every JS file that uses JSX syntaxe, needs to import NevinhaDOM method. The App component As we said, create a nevinha component is so easy, all that you need is create a class extending NevinhaComponent class and parse your HTML markup in the render method. Let's see how it's in the code: app.js class App extends NevinhaComponent { render() { return ( Hello I'm a Nevinha component and I'm using the scaleBounce animation effect ); } } If you have already used any component library like React you are used to use JSX language and our lifecycles methods is so similar to React lifecycles. You can see more details about states and components lifecycle in the Lifecycles, states and props section. Problably you noticed that our App component is using a motion prop called scaleBounce, wich makes your element be animated with a scale effect. You can see more details about motions animation props in the Motions section. State-full and State-less components We also have state-full and state-less components as React has, our App Component for example, is a state-full component, and you also can have methods and markup logic inside it, like the example bellow: class App extends NevinhaComponent { constructor() { super(); this.handleKeyPress = this.handleKeyPress.bind(this); } handleKeyPress({target}) { this.setState({ name: target.value }); } render() { const {name} = this.state; return ( Hello! This is the new: {name ? name : 'NevinhaJS'} ); } } In this example above, we are using the constructor method to bind the App context into the handleKeyPress method (to avoid the inline bind in the JSX markup), as we aren't receiving props and children, we don't need to parse them in the super() call. In this example above, we are receiving a target object that contains a value of the inputed information in the Form component. When this information is typed, we updated the state with the new value, wich will triger the NevinhaJs Diff algorithm, and will or wont display the name that is compared in the render condition name ? name : 'NevinhaJS'. To create a state-less component, you just need to create a anonymous function returning a JSX syntaxe, like the example bellow: const someComponent = ({name}, children) = { return ( Hello, my name is {name} ); } The render method Now that we have our App component created, we just need to create a HTML file with the element wich will have our NevinhaJs application running and our render method. Let's create a very simple html file: After we created our HTML file, we can call the render method in the end of our App.js file: app.js const $root = document.querySelector('my-app'); render(App, $root); What's next? Now that you have completed the basics steps to create a simple NevinhaJs component, you can follow reading about Lifecycle, states and props ","srcFilePath":"src/pages/docs/basics/creating-your-fisrt-component.md","id":"creating-your-fisrt-component","location":"/docs/basics/creating-your-fisrt-component.html","url":"/docs/basics/creating-your-fisrt-component.html"}},"title":"Basics","description":"To start to use NevinhaJs in your project is very simple and easy, if you don't want to spend time configuring your project, checkout NevinhaJS Boirlaplate by clicking in the button bellow.","layout":"guide","icon":"arrow-right-rod","weight":1,"content":" What's NevinhaJs NevinhaJs is an inteligent javascript framework that helps developers to create components and motions in a very simple and fast way. {$page.description} NevinhaJS Boirlaplate Configuring Assuming that you already have your ES6 environment configured with babel (if you dont know how to configure a babel environment, you can download our NevinhaJS Boirlaplate ⬆), you just need to add in your package.json the nevinhajs through the command: yarn add nevinha-js if you don't have yarn, you can use the npm command: npm install nevinha-js We use JSX syntaxe by default, so you'll need to add the transform-react-jsx babel plugin to convert the JSX to javascript: yarn add -D babel-plugin-transform-react-jsx After that in your .babelrc file, you have to put the follow lines: \"plugins\": [ [ \"transform-react-jsx\", { \"pragma\": \"NevinhaDOM\" } ] ] What's next? Now you know how to setup NevinhaJs in your project, let's see how to create our first component. ","srcFilePath":"src/pages/docs/basics/index.md","id":"basics","location":"/docs/basics/","url":"/docs/basics/","childIds":["creating-your-fisrt-component"]},"lifecycle-state-props":{"title":"Lifecycle, state and props","description":"When we were creating NevinhaJs, we noticed that even being a framework animation based, we would need some thing to control our components animations states and references of our components tags DOM representations. The follow topics in this section, will show you how to do it.","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} State and how to update have the control of your components is primordial in any web application, knowing that, we have developed a very simple way to control and update your component state. You just need to call the setState() method to delete, update or add a new state: handleKeyPress(){ setState({ fooValue: 'foo' }) } In the example above, we are adding or updating the state of fooValue of our component when the handleKeyPress method is called. If the fooValue state is used in the render method of our component, this component will call the render method again, to update the HTML tag or the value that was changed. Now if you use this.state.fooValue in your component, you will get the new or the updated value of foo. You can also edit more than one state in the setState method, you just need to parse the object: value follow by , in the setState method. Props, context and children When you share values between components, we call it props, or if you are parsing a HTML markup by the component declaration, we call it children. A very simple way to parse props or children for some component is using a state-less component, for example: const WelcomeMessage = ({userName}, children) = { return ( Welcome MR. {userName} ) } class MyCompnoent extends NevinhaComponent { render() { return ( This component bellow shows a welcome message: ); } } You can also parse a HTML markup for your component and access it using the children paramiter const WelcomeMessage = ({userName}, children) = { return ( Welcome MR. {userName} These are my children: {children} ) } class MyCompnoent extends NevinhaComponent { render() { return ( This component bellow shows a welcome message: Github User: clovisdasilvaneto Age: 23 ); } } If you needs to have a state and props in your child component, you can use a state-full component, like bellow: class WelcomeMessage extends NevinhaComponent { constructor(props, context){ super(props, context); this.state.someState = 'NevinhaJS'; } render() { const {userName} = this.props; const {someState} = this.state; return ( Welcome MR. {userName} My state is: {someState} These are my children: {this.children} ) } } class MyCompnoent extends NevinhaComponent { render() { return ( This component bellow shows a welcome message: Github User: clovisdasilvaneto Age: 23 ); } } *ps: You don't need to call the constructor method to use props or children in your state-full component, but if you call the constructor method to initialize something like a state property, you will need to parse the props and the context as paramiters of your super() call.* Using refs Some times we want to manipulate some rendered node in our component without needs to select it by using querySelector or some related thing. In NevinhaJs it's possible using the ref attribute: class MyCompnoent extends NevinhaComponent { constructor(props, children){ super(props, children); this.handleClick = this.handleClick.bind(this); } handleClick(){ console.log(this.context.github.element); } render() { return ( Click and get the reference of the span bellow in your browser console Gtihub Username: clovisdasilvaneto ); } } Lifecycle Lifecycle is one thing that we are working to extend your component controll possibilities. At momment, we just have one lifecycle, wich is componentWillMount and it's called when your component will be attached on the DOM. We are finishing the following lifecycles: ComponentDidMount componentWillUnmount WillReceiveProps WillReceiveAnimation AnimationEnd We are so excited to finish that lifecycles and offer to you a better API to manipulate your animations. To use a lifecycle is very simple, you just need to create a method with the lifecycle name in your state-full component: class MyCompnoent extends NevinhaComponent { componentWillMount(){ console.log('The component will mount'); } render() { return ( Gtihub Username: clovisdasilvaneto ); } } ","srcFilePath":"src/pages/docs/lifecycle-state-props/index.md","id":"lifecycle-state-props","location":"/docs/lifecycle-state-props/","url":"/docs/lifecycle-state-props/"},"providers":{"title":"Providers","description":"","layout":"guide","icon":"database","weight":4,"content":" What's Providers Providers are like NevinhaJs motions, they bring some pre defined behaviors for your application, but instead of just change your component, they changes your component and append another structure HTML in your parent component. So far we have two providers implemented, but we're work to implement more, and in the near future, we'll separate the providers from the core of NevinhaJS in a especif module, in the case of you don't want to use providers in your application, you won't need load the provider code in the core of NevinhaJS library. What's next? Now that you know the theory about providers, you can follow reading about our sticky provider and how to use providers in your NevinhaJs application. ","srcFilePath":"src/pages/docs/providers/index.md","id":"providers","location":"/docs/providers/","url":"/docs/providers/","children":{"parallax":{"title":"Parallax Provider","description":"","layout":"guide","icon":"database","weight":2,"content":" What's Providers Providers are like NevinhaJs motions, they bring some pre defined behaviors for your application, but instead of just change your component, they changes your component and append another structure HTML in your parent component. So far we have two providers implemented, but we're work to implement more, and in the near future, we'll separate the providers from the core of NevinhaJS in a especif module, in the case of you don't want to use providers in your application, you won't need load the provider code in the core of NevinhaJS library. What's next? Now that you know the theory about providers, you can follow reading about our sticky provider and how to use providers in your NevinhaJs application. ","srcFilePath":"src/pages/docs/providers/parallax.md","id":"parallax","location":"/docs/providers/parallax.html","url":"/docs/providers/parallax.html"},"sticky":{"title":"Sticky Provider","description":"Sticky provider is a way to fix your component in the screen until the height of it parent finish.","layout":"guide","icon":"arrow-right-rod","weight":1,"content":" {$page.description} How to use In NevinhaJs, there's two ways to use providers in your application. Depending on how the provider has been implemented, you can use it as a inline provider, or as a component provider. In the case of the sticky provider, it has been implemented as a inline provider, so the way for using it is very simple, you just need to parse sticky as a props of your component or HTML element. You can see a use case of the sticky provider in the code bellow: const MyComponent = (props, children) = ( This is my header fixed until the end of this section Lorem Ipsum er rett og slett dummytekst fra og for trykkeindustrien. Lorem Ipsum har vært bransjens standard for dummytekst helt siden 1500-tallet, da en ukjent boktrykker stokket en mengde bokstaver for å lage et prøveeksemplar av en bok. Lorem Ipsum har tålt tidens tann usedvanlig godt, og har i tillegg til å bestå gjennom fem århundrer også tålt spranget over til elektronisk typografi uten vesentlige endringer. Lorem Ipsum ble gjort allment kjent i 1960-årene ved lanseringen av Letraset-ark med avsnitt fra Lorem Ipsum, og senere med sideombrekkingsprogrammet Aldus PageMaker som tok i bruk nettopp Lorem Ipsum for dummytekst. Det er et velkjent faktum at lesere distraheres av lesbart innhold på en side når man ser på dens layout. Poenget med å bruke Lorem Ipsum er at det har en mer eller mindre normal fordeling av bokstaver i ord, i motsetning til 'Innhold her, innhold her', og gir inntrykk av å være lesbar tekst. Mange webside- og sideombrekkingsprogrammer bruker nå Lorem Ipsum som sin standard for provisorisk tekst, og et søk etter 'Lorem Ipsum' vil avdekke mang en uferdig webside. Ulike versjoner har sprunget frem i senere år, noen ved rene uhell og andre mer planlagte (med humor o.l.). ) *Ps: In that example above, we're using a state-less component, but you can use a state-full component as you prefer.* Custom sticky configuration You can also configure your sticky position, all that you need is informing an object as value of your sticky props with your configuration values. For example: const MyComponent = (props, children) = ( This is my header fixed until the end of this section (...) ) What's next? Now that you know how to use Sticky Provider, you can learn about Parallax Provider in the next sextion ","srcFilePath":"src/pages/docs/providers/sticky.md","id":"sticky","location":"/docs/providers/sticky.html","url":"/docs/providers/sticky.html"}},"childIds":["sticky","parallax"]},"motions":{"title":"Motions","description":"Even states, props and Lifecycles, NevinhaJS has a very special set of animations and providers inside it architecture. It is what makes NevinhaJs be diferent of React and other component frameworks. Our motions you can use in any site, portal or web application.","layout":"guide","icon":"flash","weight":2,"content":" {$page.description} The basic idea of motions Creating a motion animation in your component is very simple, all that you need is put your animation name as a prop of your component or tag HTML. Like the example bellow: class SomeComponent extends NevinhaComponent { render() { return ( Here an component with a motion animation: You also can animate HTML tags ); } } In the code above, we are using inline motions, wich is the most basic way to use our motions, but if you want to controll the state of your animation, we recommend that you use controlled motions. Inline Motions As we saw in the last example, you can use motions animations in components or in HTML tags. Each motion, has a default configuration for each property value and it is the reason of you don't need to inform anything when you are using some motion, but if you prefer to subscribe the default configuration of some property, you can parse the property name and value as a object config of your props, like the example bellow: class SomeComponent extends NevinhaComponent { render() { return ( Here an component with a custom configuration of some motion animation: ); } } In the case above,our component will be animated using the journal animation in a time of 1500 milliseconds. Controlled Motions Controllod motions are recommended to use when you want to have a controll of your set of motions animations, for example, if you have a component that depending on the context it will use an specific animation to be animated. The basic way for using it, is just calling the setAnimation method with your element ref and the animation name as argument. As the code bellow: class SomeComponent extends NevinhaComponent { constructor(props, context){ super(props, context); this.handleClick = this.handleClick.bind(this); } handleClick() { this.setAnimation(this.context.message, { name: \"dance\" }); } render() { return ( Hi, I'll be animated when the button bellow is clicked. Click to animate ); } } The setAnimation method can also receives the configuration of your motion as a second argument: handleClick() { this.setAnimation(this.context.message, { name: \"dance\", values: { speed: 0.5 } }); } In the code above, your component, will be animated using the dance animation, in the time of 500 milliseconds. When you are using controlled motions, you can remove an animation using removeAnimation method with your element ref as paramiter: removeAnimation(this.context.message); What's next Now that you know how to use our motions animations, problably you'll want to know what are the name and the configurations of our animations set, wich can be find in the motions reference section ","srcFilePath":"src/pages/docs/motions/index.md","id":"motions","location":"/docs/motions/","url":"/docs/motions/","children":{"motions-reference":{"title":"Motions Reference","description":"First you need to know that NevinhaJs uses All Animation CSS3 as base of it animations, so our goal about motions is to rewrite all animations of the All Animation CSS using web animations API.","layout":"guide","weight":1,"content":" {$page.description} Animations Set So far these are the animations set that we have implemented of the All Animation CSS3 (separated by All Animations CSS3 category): Specials Pulse Animation Name: pulse Journal Animation Name: journal Dance Animation Name: dance Pulse Slow Animation Name: pulseSlow Rotate Scale Animation Name: rotateScale Bounce Enter Up Bounce Animation Name: enterUpBounce Enter Down Bounce Animation Name: enterDownBounce Enter Left Bounce Animation Name: enterLeftBounce Scale Bounce Animation Name: scaleBounce Jump Bounce Animation Name: jumpBounce Fading Entrances Fade In Animation Name: fadeIn Fade Out Animation Name: fadeOut Agrecives Flash Bang Animation Name: flash Bomb Animation Name: bomb What's next? Now that you have completed the motions section, you can learn about providers in the providers section. ","srcFilePath":"src/pages/docs/motions/motions-reference.md","id":"motions-reference","location":"/docs/motions/motions-reference.html","url":"/docs/motions/motions-reference.html"}},"childIds":["motions-reference"]}},"childIds":["basics","lifecycle-state-props","motions","providers","search"]},"tutorials":{"title":"Tutorials","description":"Foo bar.","url":"/tutorials/example/first-step.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","customURL":true,"children":{"example":{"children":{"first-step":{"title":"Step 1 - Preparing your environment","description":"","buttonTitle":"I did step 1","parentId":"example","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} First, lets create our enviromment configuration, we can start creating our package.json, something like this: { \"name\": \"nevinha-js-basic-example\", \"version\": \"1.0.0\", \"scripts\": { \"start\": \"webpack-dev-server --content-base public --inline --hot\", } } Next you'll need to install webpack for creatting a local server and the babel dependecies to transpile your code: yarn add webpack webpack-dev-server babel-core babel-eslint babel-loader babel-plugin-transform-react-jsx babel-preset-es2015 babel-preset-stage-0 After that, let's create a .babelrc file in our project, to configure the babel transpile and allow us to use es6 syntaxe: { \"presets\": [ \"es2015\", \"stage-0\" ], \"plugins\": [ [ \"transform-react-jsx\", { \"pragma\": \"NevinhaDOM\" } ] ] } Finally, let's create our webpack.config file: const path = require('path'); function resolveModule(name) { return path.resolve(__dirname, src/${name}); } module.exports = { entry: [ 'core-js/es6/symbol', 'core-js/fn/array/find', 'core-js/fn/object/assign', 'core-js/fn/string/ends-with', resolveModule('index.js') ], module: { loaders: [ {exclude: /node_modules/, loader: 'babel-loader', test: /\\.js$/} ] }, output: { filename: 'bundle.js', path: path.resolve('./dist') }, }; Now that you have completed the step 1, you can follow to the next section.","srcFilePath":"src/pages/tutorials/example/first-step.md","id":"first-step","location":"/tutorials/example/first-step.html","url":"/tutorials/example/first-step.html"},"second-step":{"title":"Step 2 - Creating your first component","description":"","parentId":"example","layout":"tutorial","buttonTitle":"I did step 2","time":90,"weight":2,"content":" {$page.title} Now that we have all of our environment configurated, we can follow creating our components. But before we do it, we need to create a folder called src and another folder called public. First, let's create a index.html file in our public folder: Document Now, let's create our app component. Inside of src folder, we'll create a app.js file, witch extends of NevinhaCompnonent and will be our app component file. Every NevinhaJs component needs to extends NevinhaComponent class, you don't need to extend from NevinhaComponent just if your component is a state-less component. Knowing that, let's import NevinhaComponent, the render to render our NevinhaJs application in the my-app element, and NevinhaDOM, wich we won't use in the code but remember that we have put NevinhaDOM as a pragma of the transform-react-jsx babel plugin and every we will use JSX sintaxe, we'll need to import NevinhaDOM. So our first app component, will look something like this: import {NevinhaComponent, render, NevinhaDOM} from 'nevinha-js'; class App extends NevinhaComponent { render() { return ( some code come here! ); } } const $root = document.querySelector('#my-app'); render(App, $root); Now you can follow for the next section, where we'll see how to update our components state, use props and animations.","srcFilePath":"src/pages/tutorials/example/second-step.md","id":"second-step","location":"/tutorials/example/second-step.html","url":"/tutorials/example/second-step.html"},"third-step":{"title":"Step 3 - Using state, props and animations","description":"","parentId":"example","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} So far we have created a very basic app component, wich don't have any state and don't use any NevinhaJs animation. Now it's time to create a basic component, that will have an input field and a text wich will reflect the value of the input. First, we'll see how to use motions in a Nevinha component, let's update the render method in our App component: class App extends NevinhaComponent { render() { const {name} = this.state; return ( Hello! This is the new: {name ? name : 'NevinhaJS'} ); } } In the component above, we're using enterLeftBounce as animation, wich will animate our app in a fadeIn effect comming from the left side of our application. Notice that we are using an inline condition to check if the state name exists, if it's not, we will show 'NevinhaJs' as a default value. Now we have to create the FormComponent wich will have an input and a footer message. The FormComponent will receives a handleKeyUp method as props for sendding our App component the value of the input when the user inputs something in our form. The FormComponent will be have the code bellow: class FormComponent extends NevinhaComponent { render() { const {handleKeyPress} = this.props; return ( Type the page name in the input above ); } } If you have used some component framework like react, you probably are familiar with the code above, but the coll thing is that we aren't using react or any other component framework but even though, we are using states, props, animations and our components are using the virtual DOM algorithms. We need to call our FormComponent inside the App component, for using it, and we also need to create a constructor method in our App component to bind the instance in the handleKeyUp method. Like the example bellow: lass App extends NevinhaComponent { constructor() { super(); this.handleKeyPress = this.handleKeyPress.bind(this); } handleKeyPress({target}) { this.setState({ name: target.value }); } render() { const {name} = this.state; return ( Hello! This is the new: {name ? name : 'NevinhaJS'} ); } } Notice that we update our state through the setState method. This method will trigger our diff internally, wich checks wich changes in the virtual DOM and updates them. For finishing our app, you can create a style.css file in the public folder, just to stylize your app: body { background: f5f5f5; font: 24px 'Open Sans', sans-serif; margin: 0; } my-app { position: relative; } .height { height: 100vh; padding-top: 1px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; } .margin-hello { margin: 10px 0; font-size: 2rem; } .form { display: block; text-align: center; width: 500px; margin: 0 auto; } .hello { text-align: center; color: rgba(175, 47, 47, 0.15); font-size: 5rem; min-height: 138px; } input { text-align: center; font-size: 1.6rem; padding: 24px 0; width: 100%; border: none; box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.22); } footer { font-size: 1rem; color: bfbfbf; line-height: 2; } Don't forget to call the style.css file in your index.html file: Document Now you can run in your terminal yarn start and see our example working. ","srcFilePath":"src/pages/tutorials/example/third-step.md","id":"third-step","location":"/tutorials/example/third-step.html","url":"/tutorials/example/third-step.html"}},"title":"First Tutorial","description":"Foo bar.","tutorialTitle":"Getting started with your first tutorial","url":"/tutorials/example/first-step.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/example/index.soy","id":"example","location":"/tutorials/example/","customURL":true,"childIds":["first-step","second-step","third-step"]}},"childIds":["example"]}},"childIds":["docs","tutorials"]}}